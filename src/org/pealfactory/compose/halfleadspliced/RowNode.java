package org.pealfactory.compose.halfleadspliced;

import org.pealfactory.ring.*;

/**
 * Represent a single Row together with precalculated table values to increase
 * performance. Every RowNode has a table of pointers (fPermLinks) to those RowNodes
 * which would be reached by every possible place notation permutation in the table
 * of methods. This means expensive place notation operations are not longer
 * necessary - a change can be generated simply by accessing the fPermLink array.
 * <p>
 * For those RowNodes representing potential leadheads (i.e. any with the treble home)
 * the fPermLinks array also contain pointers to the nodes which would be reached
 * by permutation with any of the leadheads in the table of methods. The leadhead
 * of a composition can therefore be generated by a single table lookup.
 * <p>
 * Leadhead nodes also contain a table of precalculated music scores for every method
 * (fLeadMusic). This allows music scoring to proceed with just one operation per lead.
 * <p>
 * For this class, performance is all!
 *
 * @author MBD
 */
class RowNode extends ImmutableRow
{
	private int fNodeNumber;
	/** Music score for this one row */
	private int fMusic;
	private RowNode[] fPermLinks;
	/** true if treble at lead */
	private boolean fLeadhead;
	/** Only set if treble home: music for entire lead of each (composite) method */
	private int[] fLeadMusic;
	//private int[][] fExpandedRows;
	/** Only valid if treble home */
	private int fLeadheadNumber;
	private int fNParts;
	private boolean fNicePartEnd = false;
    /**  */
	/** Only valid if treble home and tenors together */
	private int fLeadsTillTenorsHome;
	private int fRegenOffset;

	RowNode(Row row, Tables tables)
	{
		super(row);
		fNodeNumber = tables.newNodeNumber();
		fLeadhead = (bellAt(1)==1);
		// Calc n parts & nice-part end
		calcPartStats();
		// The value to set the regen pointer to when backtracking.
		// Only ever changed for tenors-together leadhead nodes when doing
		// tenors-together search.
		fRegenOffset = 0;
	}

	/**
	 * Final for speed (inlining)
	 */
	public final RowNode permute(int permNum)
	{
		return fPermLinks[permNum];
	}

	/**
	 * Final for speed (inlining)
	 */
	public final int getNodeNumber()
	{
		return fNodeNumber;
	}

	/**
	 * Final for speed.
	 */
	public final int getLeadheadNumber()
	{
		return fLeadheadNumber;
	}

	public void setLeadheadNumber(int leadheadNumber)
	{
		fLeadheadNumber = leadheadNumber;
	}

	/**
	 * Final for speed (inlining)
	 */
	public final int getMusic()
	{
		return fMusic;
	}

	/**
	 * Returns true if treble at lead for this row.
	 * Final for speed (inlining)
	 */
	public final boolean isLeadhead()
	{
		return fLeadhead;
	}

	/**
	 * Final for speed (inlining)
	 */
	public final int getNParts()
	{
		return fNParts;
	}

	/**
	 * Final for speed (inlining)
	 */
	public final boolean isNicePartEnd()
	{
		return fNicePartEnd;
	}

	/**
	 * Gets music for entire lead.
	 * Final for speed.
	 */
	public final int getLeadMusic(int m)
	{
		return fLeadMusic[m];
	}

	protected final void calcLeadMusic(Method method)
	{
		int m = method.getMethodIndex();
		fLeadMusic[m] = method.leadMusic(this);
	}

	/**
	 * Final for speed.
	 */
	public final int getRegenOffset()
	{
		return fRegenOffset;
	}

	/**
	 * Should only be called on tenors-together leadhead nodes.
	 * If tenorsTogether parameter is true, sets fRegenOffset to
	 * be equal to -fLeadsToTenorsHome, which must already have been
	 * set for the 0th method in the search by calcLeadsToTenorsHome().
	 * Otherwise, fRegenOffset is set to 0.
	 */
	public final void setRegenOffset(boolean tenorsTogether)
	{
		if (tenorsTogether)
			fRegenOffset = -fLeadsTillTenorsHome;
		else
			fRegenOffset = 0;
	}

	/**
	 * Returns false if error.
	 * LeadheadPerms are perms backstroke lh to handstroke le.
	 * Very important - this call also clears out the node-music table,
	 * so MUST BE CALLED whenever the methods list is changed (even if it
	 * is only re-ordered).
	 */
	boolean calcPermLinks(Tables tables, byte[][] pnPerms, byte[][] leadheadPerms)
	{
		int n0 = pnPerms.length;
		int n = n0;
		if (fLeadhead)
			n+= leadheadPerms.length;
		fPermLinks = new RowNode[n];

		// For speed, we use mutable Rows to calculate the permutations - but
		// these have to be reset every time.
		String thisRow = toString();
		Row row = new Row(getNBells());
		for (int i=0; i<n0; i++)
		{
			row.setRow(thisRow);
			row.applyPermutation(pnPerms[i]);
			RowNode node = tables.getNode(row);
			if (node==null)
			{
				System.out.println("FATAL ERROR: node not found in table: "+row);
				return false;
			}
			fPermLinks[i] = node;
		}
		if (fLeadhead)
		{
			fLeadMusic = new int[tables.getNCompositeMethods()];
			n = leadheadPerms.length;
			for (int i=0; i<n; i++)
			{
				row.setRow(thisRow);
				row.applyPermutation(leadheadPerms[i]);
				RowNode node = tables.getNode(row);
				if (node==null)
				{
					System.out.println("FATAL ERROR: node not found in table: "+row);
					return false;
				}
				fPermLinks[i+n0] = node;
			}
		}
		return true;
	}

	/**
	 */
	private void calcNicePartEnd(Music[] parts)
	{
		fNicePartEnd = false;
		for (int i=parts.length-1; i>=0; i--)
			if (score(parts[i])>0)
			{
				fNicePartEnd = true;
				return;
			}
	}

	/**
	 * Must ONLY be called on tenors-together nodes with the treble leading.
	 * May fail for differential methods!
	 */
	protected void calcLeadsToTenorsHome(Method method0)
	{
        fLeadsTillTenorsHome = 0;
		RowNode node = this;
		for (int i=0; i<fNBells-1; i++)
		{
			if (node.isTenorsHome())
				return;
			fLeadsTillTenorsHome++;
			node = node.permute(method0.getLeadPermNum(0));
		}
		System.out.println("WARNING: overflow in calcLeadsToTenorsHome "+this);
	}

	/**
	 */
	protected void calcMusicScore(Music[] music)
	{
		fMusic = 0;
		for (int i=music.length-1; i>=0; i--)
			fMusic+= score(music[i]);
	}

	/**
	 * Final for speed.
	 */
	private final int score(Music music)
	{
		String[] matches = music.getMatches();
		for (int i=matches.length-1; i>=0; i--)
		{
			String match = matches[i];
			int j;
			for (j=fNBells-1; j>=0; j--)
			{
				char c = match.charAt(j);
				if (c!=Music.kWILDCARD && c!=fRow[j])
					break;
			}
			if (j<0)
				return music.getScore();
		}
		return 0;
	}

	private void calcPartStats()
	{
		fNParts = 0;
		if (fLeadhead)
		{
			Row start = new Row(fNBells);
			byte[] perm = toBytes();
			do
			{
				fNParts++;
				start.applyPermutation(perm);
			} while (!start.equals(kROUNDS_ROW));
			calcNicePartEnd(Music.kPARTS);
		}
	}

}
